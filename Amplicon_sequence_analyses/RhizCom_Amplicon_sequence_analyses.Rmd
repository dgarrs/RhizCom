---
title: "RhizCom propagation: Microbiome analyses"
author: "Daniel Garrido-Sanz (daniel.garridosanz@unil.ch)"
affiliation: "Kell Lab | Department of fundamental microbiology | University of Lausanne"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  rmdformats::html_clean:
    code_folding: hide
    toc: true
    thumbnails: false
    toc_depth: 3
pkgdown:
  as_is: true
---

```{r, echo = FALSE}
#For installing downcute: install rmdformats package and include "output: rmdformats::downcute" in the header.
#knitting options:
knitr::opts_chunk$set(eval=TRUE, cache=TRUE, echo=TRUE, warning=FALSE, error=FALSE, message=FALSE, include=TRUE, strip.white=TRUE)
```

Code used for the analysis of raw amplicon sequences to ASVs can be found in Garrido-Sanz, D. et al. Changes in structure and assembly of a species-rich soil natural community with contrasting nutrient availability upon establishment of a plant-beneficial Pseudomonas in the wheat rhizosphere. Microbiome 11, 214 (2023). https://doi.org/10.1186/s40168-023-01660-5 

# 1. Load Required packages

```{r, warning=FALSE, message=FALSE}
library(dada2)
library(phyloseq)
library(Biostrings)
library(ggplot2)
library(ggalluvial)
library(ggh4x)
library(tidyverse)
library(ggrepel)
library(qiime2R)
library(dplyr)
library(DESeq2)
library(pals)
library(ggforce)
library(gridExtra)
library(vegan)
library(data.table)
library(ggpubr)
library(picante)
library(ggtreeExtra)
library(ggpmisc)
library(DECIPHER) #BiocManager::install("DECIPHER")
library(phangorn) #remotes::install_github("KlausVigo/phangorn")
library(ggtree) #BiocManager::install("ggtree")
library(plotly)
library(speedyseq) #remotes::install_github("mikemc/speedyseq")
library(ComplexHeatmap)
library(agricolae)
library(scales)
library(ggpmisc)
library(pairwiseAdonis)#library(devtools) install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(phyloseq.extended)#remotes::install_github(repo = "mahendra-mariadassou/phyloseq-extended@v0.1.0.9000-beta", ref = "dev")

#The following need to be installed but NOT loaded (same naming of different functions):
#library(metagMisc) #devtools::install_github("vmikk/metagMisc")
#library(metagenomeSeq) #BiocManager::install("metagenomeSeq")
#library(ranacapa) #remotes::install_github("gauravsk/ranacapa")
```

# 2. Load DADA2 results

Taxa table and ASVs sequences

```{r}
taxa2 = read.table(file="Taxtable_dada2.txt", sep=";", header=T)
taxa2 = column_to_rownames(as.data.frame(taxa2), "X")

seqtab.nochim2 = fread(file="ASV_sequences.txt", sep=";", header=T)
seqtab.nochim2 = column_to_rownames(as.data.frame(seqtab.nochim2), "V1")
#correct names
rownames(seqtab.nochim2) = gsub("_$", "", rownames(seqtab.nochim2))
head(seqtab.nochim2)
```

load the phylogeny

```{r}
tree = read.tree("seqtab.nochim_aln.fasta.treefile")

#Rename tips labels to match those in the taxa
index = data.frame(seqs = rownames(taxa2))
index = rownames_to_column(index, "index")
tip_names = data.frame(index = tree$tip.label)
tip_tax = left_join(tip_names, index, by = "index")
tree$tip.label = tip_tax$seqs
```

# 3. Load metadata file

```{r}
metadata = read.table("metadata.txt", header = T, sep = "\t")
rownames(metadata) = metadata$id_samples
head(metadata)

```

# 4. Create the phyloseq object

```{r}
#Or read the RDS if previously saved the PS object
#ps = readRDS("phyloseq_object.rds")

ps = phyloseq(otu_table(seqtab.nochim2, taxa_are_rows=F), 
               sample_data(metadata), 
               tax_table(as.matrix(taxa2)),
               phy_tree(tree))

#rename ASVs by ASV1, ASV2, ASV3...
dna = Biostrings::DNAStringSet(taxa_names(ps))
names(dna) = taxa_names(ps)
ps = merge_phyloseq(ps, dna)
taxa_names(ps) = paste0("ASV", seq(ntaxa(ps)))

ps

#write the refseqs
#write.table(refseq(ps), "ref-seq.txt", sep = "\t", quote = F, col.names = F)
#write the phyloseq object
#saveRDS(ps, "phyloseq_object.rds")
```

# 5. Filter the phyloseq object

## 5.1 Remove Mitochondria and Chloroplasts

```{r}
ps = subset_taxa(ps, Genus!="Mitochondria")
ps = subset_taxa(ps, Genus!="Chloroplast")
ps
```

## 5.2 Prevalence filtering

Obtained from: https://f1000research.com/articles/5-1492/v1
One of the reasons to filter by prevalence is to avoid spending much time analyzing taxa that were only rarely seen. This also turns out to be a useful filter of noise (taxa that are actually just artifacts of the data collection process).

```{r}
# Define prevalence of each taxa
# (in how many samples did each taxa appear at least once)
prev0 = apply(X = otu_table(ps),
                MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
                FUN = function(x){sum(x > 0)})

prevdf = data.frame(Prevalence = prev0,
                      TotalAbundance = taxa_sums(ps),
                      tax_table(ps))

#only for reference, in case we want to filter Phyla that appear less than X times
keepPhyla = table(prevdf$Phylum)[(table(prevdf$Phylum) > 0)]

prevdf1 = subset(prevdf, Phylum %in% names(keepPhyla))

# Define prevalence threshold as 1% of total samples
prevalenceThreshold = 0.01 * nsamples(ps)
prevalenceThreshold

# Execute prevalence filter, using `prune_taxa()` function
ps1 = prune_taxa((prev0 > prevalenceThreshold), ps)
ps1

# Filter entries with unidentified Phylum.
ps2 = subset_taxa(ps1, Phylum %in% names(keepPhyla))
ps2

ggplot(prevdf1, aes(TotalAbundance, Prevalence, color = Phylum)) +
  geom_hline(yintercept = prevalenceThreshold, alpha = 0.5, linetype = 2) +
  geom_point(size = 2, alpha = 0.65) +
  scale_y_log10() + scale_x_log10() +
  ggtitle(paste0("Prevalence filtering, using a threshold of ", prevalenceThreshold))+
  xlab("Total Abundance") +
  scale_color_manual(values=ocean.balance(22))+
  theme_bw()+
  facet_wrap(~Phylum, nrow = 4)

```

How many of this low frequency ASVs have been removed?

```{r}
print(paste0("Initial #ASVs:", ntaxa(ps), ". #ASVs after prevalence filtering:", ntaxa(ps2), ". #ASVs removed: ", ntaxa(ps)-ntaxa(ps2)))
```

Save the ps2 otu_table and relative abundance otu table 

```{r}
#write.table(otu_table(ps2), "otu_table_ps2.txt", quote = F, sep = "\t")

#Or transformed to relative abundances
ps2.prop = transform_sample_counts(ps2, function(x) {x/sum(x)*100})
#write.table(otu_table(ps2.prop), "otu_table_ps2_prop.txt", quote = F, sep = "\t")
```

# 6. Bar plots:

```{r}
#Showing individual replicates. Top 500 taxa
toptax = names(sort(taxa_sums(ps2), decreasing=TRUE))[1:500]
ps.toptax = transform_sample_counts(ps2, function(x) {x/sum(x)*100})
ps.toptax <- prune_taxa(toptax, ps.toptax)

#Class level
psmelt(ps.toptax)
ggplot(psmelt(ps.toptax), aes(x=reorder(Names_rep, sample_Order), y=Abundance, fill=Class))+
  geom_bar(stat = "identity", position = "stack", width = 1) +
  #scale_fill_manual(values=c(ocean.dense(7), ocean.tempo(8)))+
  scale_fill_manual(values=c("#25725d", "#439b5b", "#7bc369", "#abd69a", "#d8e8b0", "#cccda7", "#bfb77b", "#7e9998", "#92B2B2", "#83bbbf", "#61acc1", "#58a0c4", "#7087c3","#8973b4", "#512972"))+
  xlab("") + ylab("Relative abundance (%)") +
  facet_wrap(~reorder(Name, sample_Order), scales = "free_x", nrow = 1) + 
  ggtitle("Class, top 500 ASVs") +
  theme_pubclean() + theme(legend.position="bottom", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 

```


## 6.2 Export Taxa and ASVs table

Export the tax_table and otu_table at the genus level

```{r}
ps2.prop.tax = tax_table(ps2.prop) %>% as.data.frame() %>% rownames_to_column("ASVs")
ps2.prop.asv = t(otu_table(ps2.prop)) %>% as.data.frame() 
colnames(ps2.prop.asv) = sample_data(ps2.prop)$Names_rep
ps2.prop.asv =  rownames_to_column(ps2.prop.asv, "ASVs")

#write.table(left_join(ps2.prop.tax, ps2.prop.asv, by="ASVs"), "Tax_ASV_table.txt", quote = F, sep = "\t", row.names = F)
```

## 6.3 CSS normalization

For certain downstream analyses; for example to compare different abundances of taxa between samples, the counts needs to be normalized to account for different sampling efforts, exposures, baselines, etc. We will normalize the samples using the CSS (Cumulative Sum Scaling) introduced in (Paulson et al. 2013), where the offset of a sample is the cumulative sum of counts in that sample, up to a quantile determined in a data driven way. Calculates scaling factors as the cumulative sum of ASVs abundances up to a data-derived threshold.

```{r}
#Ussing the CSS
ps2.css = metagMisc::phyloseq_transform_css(ps2, norm = T, log = F) #log2 FALSE!
ps2.css = orient_taxa(ps2.css, "columns") #change taxa to columns
#and the the TSS (proportion; relative abundance)
ps2.css.prop = transform_sample_counts(ps2.css, function(x) {x/sum(x)*100})


ggplot(psmelt(prune_taxa(toptax, ps2.css.prop)), aes(x=reorder(Names_rep, sample_Order), y=Abundance, fill=Class))+
  geom_bar(stat = "identity", position = "stack", width = 1) +
  scale_fill_manual(values=c("#25725d", "#439b5b", "#7bc369", "#abd69a", "#d8e8b0", "#cccda7", "#bfb77b", "#7e9998", "#92B2B2", "#83bbbf", "#61acc1", "#58a0c4", "#7087c3", "#8973b4", "#512972"))+
  xlab("") + ylab("CSS-Normalized relative abundance (%)") +
  facet_wrap(~reorder(Name, sample_Order), scales = "free_x", nrow = 1) + 
  ggtitle("Class, top 500 ASVs") + xlab("CSS-Normalized relative abundance (%)")
  theme_pubclean() + theme(legend.position="bottom", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

## 6.4 Differences at the Class level.

```{r warning=FALSE}
#Merge taxa by Class
Class_glom = tax_glom(ps2.css.prop, taxrank = "Class")

#merge the sample_data with the otu_table and melt
Class_abund = left_join(data.frame(sample_data(Class_glom)), rownames_to_column(data.frame(otu_table(Class_glom)), "id_samples"), by=c("id_samples"))
Class_abund.melt = Class_abund %>% select(-Replicate, -Order, -RGBcol) %>% melt(value.name = "abund") %>% left_join(select(metadata, Name, Order), by=c("Name"))

#add taxa name to ASVs
Class_tax = as.data.frame(tax_table(Class_glom)) %>% rownames_to_column(var = "asvs") %>% select(-Order, -Family, -Genus, -Species, -Species.1)
#merge with the molten abundance
Class_abundtax = left_join(Class_abund.melt, Class_tax, by=c("variable"="asvs"))

ggplot(filter(Class_abundtax, Class == "Bacteroidia" | Class == "Gammaproteobacteria" | Class == "Bacilli" |
                Class == "Alphaproteobacteria" | Class == "Actinobacteria" | Class == "Verrucomicrobiae" |
                Class == "Bdellovibrionia" | Class == "Fimbriimonadia" | Class == "Planctomycetes"  |
                Class == "Myxococcia" | Class == "Thermoleophilia" | Class == "Gemmatimonadetes"),
       aes(x=reorder(Name, Order), y=abund)) +
  geom_boxplot(width=0.9)+
  geom_jitter(aes(color=Class), size=0.5, shape=16)+
  xlab("") + ylab("ASVs normalized relative abundance (%)")+
  ggtitle("Class abundance", subtitle = "significance: Kruskal test")+
  scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x), 
                labels = trans_format("log10", math_format(10^.x)))+
  annotation_logticks(sides = "l") +
  facet_wrap(~Class, nrow = 3)+
  theme_pubclean() + theme(axis.text.x = element_text(angle = 90, vjust =1, hjust=1))
```


### 6.4.1 Stats

Test assumptions to know which test should be performed:

```{r warning=FALSE}
# Check assumptions: normality and homogeneity of variances
# Normality test
shapiro.test(sample(Class_abundtax$abund, 5000))

# Homogeneity of variances test
car::leveneTest(abund ~ Name, data = Class_abundtax)

# Perform ANOVA or Kruskal-Wallis based on the assumption tests
if (shapiro.test(sample(Class_abundtax$abund, 5000))$p.value > 0.05 & car::leveneTest(abund ~ Name, data = Class_abundtax)$`Pr(>F)`[1] > 0.05) {
  print("You should perform ANOVA test")
} else {
  print("You should perform Kruskal-Wallis test")
}
```

We will use Kruskal-Wallis with post hoc test using the criteria Fisher's least significant differences and the BH (==FDR) adjusted p-value.

```{r}
Class_abundtax_top = filter(Class_abundtax,Class == "Bacteroidia" | Class == "Gammaproteobacteria" | Class == "Bacilli" |
                Class == "Alphaproteobacteria" | Class == "Actinobacteria" | Class == "Verrucomicrobiae" |
                Class == "Bdellovibrionia" | Class == "Fimbriimonadia" | Class == "Planctomycetes"  |
                Class == "Myxococcia" | Class == "Thermoleophilia" | Class == "Gemmatimonadetes")

#Empty df to store results
anovaClassres = data.frame()

for (i in unique(Class_abundtax_top$Class)){
  class_filt = filter(Class_abundtax_top, Class==i)
  kw = agricolae::kruskal(class_filt$abund, class_filt$Name, p.adj = "BH")
  kwres = rownames_to_column(kw$groups, var="Name")
  classp = ggplot(class_filt, aes(x=reorder(Name, Order), y=abund))+
    geom_boxplot(width=0.9)+
    geom_jitter(aes(color=Class), size=0.5, shape=16)+
    annotate(geom = "text", x=kwres$Name, y=30, label=kwres$groups)+
    xlab("") + ylab("ASVs normalized relative abundance (%)")+
    ggtitle("Class abundance", subtitle = paste0("Kruskal-Wallis p-value = ",  kw$statistics$p.chisq))+
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x))+
    annotation_logticks(sides = "l") +
    facet_wrap(~Class, nrow = 1)+
    theme_pubclean() + theme(axis.text.x = element_text(angle = 90, vjust =1, hjust=1))
  
  plot(classp)
  
  modelClass  <- lm(class_filt$abund ~ class_filt$Names, data = class_filt)
  anovaClass = anova(modelClass) %>% rownames_to_column(var="variable")
  anovaClass.all = cbind(i, anovaClass)
  anovaClassres = rbind(anovaClassres, anovaClass.all)
}


#write.table(anovaClassres, "anovaClass_results_variables.txt", quote = F, sep = "\t", row.names = F)
```


# 7. CFUs/g

Note: There's not initial soil... as i can only plate what is recovered after mixing soil + solution == soil wash.

```{r}
cfus = read.table("RhizCom_CFUs.txt", header = T, sep = "\t")
cfus_filt = filter(cfus, Environment != "Bulk" & Soil=="S16" | Soil=="STB")


kw = agricolae::kruskal(cfus_filt$CFUs_g, cfus_filt$Condition, p.adj = "BH")
kwres = rownames_to_column(kw$groups, var="Name")

ggplot(cfus_filt, aes(x = reorder(Condition, order), y = log(CFUs_g,10), fill = Condition)) +
  geom_boxplot() + 
  geom_jitter(aes(x = Condition, y=log(CFUs_g,10), color = Condition), 
              size=2, alpha = 0.6, position = "jitter") +
  annotate(geom = "text", x=kwres$Name, y=8.5, label=kwres$groups)+
  ggtitle("CFUs", subtitle = paste0("Kruskal-Wallis p-value = ",
                                   kw$statistics$p.chisq))+
  scale_color_manual(values=unique(cfus_filt$RGB_col))+
  scale_fill_manual(values=unique(cfus_filt$RGB_col))+
  theme_classic() + ylab("log10(CFUsÂ· g-1 of matrix/rhizosphere)") + xlab("")

```


# 8. Rarefaction Curves

Next step is to calculate the rarefaction curves: observed ASVs along the sequencing depth (adapted from: https://github.com/joey711/phyloseq/issues/143)

```{r}
#calculate rarefaction curves using 500 step size and calculating the standard error
rare = ggrare(ps2, step = 500, color = "Name", label = "Names_rep", se = T, parallel = T, plot = F)

#save/load as it takes some time to compute
#saveRDS("rare", "rare.rds")
#readRDS("rare.rds")
```

```{r}
rare = rare + 
  scale_y_continuous(breaks = c(0,250,500,750,1000,1250,1500,1750,2000))+
  scale_color_manual(values=unique(metadata$RGBcol)) +
  scale_fill_manual(values=unique(metadata$RGBcol)) +
  scale_x_continuous(labels = comma) +
  xlab("Sequencing depth (bp)") + ylab("Observed ASVs")+
  #facet_wrap(~ComState, scales = "free_x") + 
  theme_pubclean() + theme(axis.line.x = element_line(),
                           axis.line.y = element_line())

rare
```

# 9. Diversity

## 9.1 Diversity indexes

```{r}
order.samples = c("Soil","SoilWash","Cycle1","Cycle2", "Cycle3","Cycle4","Cycle5","Cycle6","Recovered","SbRB")

#Observed ASVs
diver.ob = plot_richness(ps2, x="Name", measures=c("Observed"))+
  geom_bar(position = "identity", stat = "summary", aes(y=value), fill="darkgrey")+
  geom_errorbar(stat = "summary", width=0.75, aes(y=value)) + 
  geom_jitter(width = 0.2, alpha=0.75, size=1, aes(y=value))+
  facet_wrap(~variable,scales = "free_x", nrow = 1)+
  theme_pubclean() + theme(legend.position = "bottom", 
                           axis.text.x = element_text(angle = 90, vjust = 0, hjust=1))

diver.ob$layers = diver.ob$layers[-1]
diver.ob$data$Name <- as.character(diver.ob$data$Name)
diver.ob$data$Name <- factor(diver.ob$data$Name, levels=order.samples)

#Saannon
diver.sha = plot_richness(ps2, x="Name", measures=c("Shannon"))+
  geom_bar(position = "identity", stat = "summary", aes(y=value), fill="darkgrey")+
  geom_errorbar(stat = "summary", width=0.75, aes(y=value)) + 
  geom_jitter(width = 0.2, alpha=0.75, size=1, aes(y=value))+
  facet_wrap(~variable,scales = "free_x", nrow = 1)+
  theme_pubclean() + theme(legend.position = "bottom", 
                           axis.text.x = element_text(angle = 90, vjust = 0, hjust=1))
diver.sha$layers = diver.sha$layers[-1]
diver.sha$data$Name <- as.character(diver.sha$data$Name)
diver.sha$data$Name <- factor(diver.sha$data$Name, levels=order.samples)

#Simpson
diver.sim = plot_richness(ps2, x="Name", measures=c("Simpson"))+
  geom_bar(position = "identity", stat = "summary", aes(y=value), fill="darkgrey")+
  geom_errorbar(stat = "summary", width=0.75, aes(y=value)) + 
  geom_jitter(width = 0.2, alpha=0.75, size=1, aes(y=value))+
  facet_wrap(~variable,scales = "free_x", nrow = 1)+
  theme_pubclean() + theme(legend.position = "bottom", 
                           axis.text.x = element_text(angle = 90, vjust = 0, hjust=1))

diver.sim$layers = diver.sim$layers[-1]
diver.sim$data$Name <- as.character(diver.sim$data$Name)
diver.sim$data$Name <- factor(diver.sim$data$Name, levels=order.samples)

#Faith's PD
pd = pd(otu_table(ps2), phy_tree(ps2), include.root = F)
pd = pd %>% rownames_to_column("id_samples") %>% left_join(metadata, by="id_samples")
diver.pd = ggplot(pd, aes(Name, PD)) + 
  geom_bar(position = "identity", stat = "summary", aes(y=PD), fill="darkgrey")+
  geom_errorbar(stat = "summary",width=0.75, aes(y=PD)) + 
  geom_jitter(width = 0.2, alpha=0.75, size=1, aes(y=PD))+
  facet_wrap(NULL, labeller=as_labeller(c("(all)"="Faith's PD")))+
  theme_pubclean() + theme(legend.position = "bottom", 
                           axis.text.x = element_text(angle = 90, vjust = 0, hjust=1)) + xlab("")
  

diver.pd$data$Name = as.character(diver.pd$data$Name)
diver.pd$data$Name = factor(diver.pd$data$Name, levels=order.samples)

ggarrange(diver.ob+theme(legend.position = "", axis.line = element_line())+scale_color_manual(values=metadata$RGBcol),
          diver.sha+theme(legend.position = "", axis.line = element_line())+scale_color_manual(values=metadata$RGBcol),
          diver.pd+theme(legend.position = "", axis.line = element_line())+scale_color_manual(values=metadata$RGBcol),
          diver.sim+theme(legend.position = "", axis.line = element_line())+scale_color_manual(values=metadata$RGBcol),
          ncol=2, nrow = 2, common.legend = T, legend = "bottom", align = "hv")


#Save all diversity values in a table

diversity_all = pd %>% dplyr::select(id_samples, Name, PD)  %>% 
  left_join(select(diver.ob$data, id_samples, Observed_ASVs = value), by = c("id_samples")) %>%
  left_join(select(diver.sha$data, id_samples, Shannon = value), by = c("id_samples")) %>%
  left_join(select(diver.sim$data, id_samples, Simpson = value), by = c("id_samples"))

#write.table(diversity_all, "Diversity_indexes.txt", quote = F, sep = "\t", row.names = F)

```


Multiple comparison test.

```{r}
div.melt = reshape2::melt(diversity_all)
#reattach the order
div.melt = div.melt %>% left_join(select(metadata, id_samples, Order), by = c("id_samples"))

#Store results in empty df
Kruskal.Diver.res = data.frame()

order.div = c("Observed_ASVs", "Shannon", "Simpson", "PD")

for (i in order.div){
  diver_filt = filter(div.melt, variable==i)
  kw = agricolae::kruskal(diver_filt$value, diver_filt$Name, alpha = 0.05, p.adj = "fdr")
  kwres = rownames_to_column(kw$groups, var="Name")
  obsp = ggplot(diver_filt, aes(x=reorder(Name, Order), y=value))+
    geom_boxplot(width=0.9)+
    geom_jitter(aes(color=Name), size=1, shape=16)+
    annotate(geom = "text", x=kwres$Name, y=50, label=kwres$groups)+
    xlab("") + ylab("Diversity measure")+
    ggtitle(paste0(i), subtitle = paste0("Kruskal-Wallis p-value = ",  kw$statistics$p.chisq))+
    theme_pubclean() + theme(axis.text.x = element_text(angle = 90, vjust =1, hjust=1))
  
  plot(obsp)
}
```


## 9.2 Correlation with succession cycles

```{r}
#OBSERVED ASVs
#only select cycles, and take cycle number to account for the time series
diver.ob.good = diver.ob$data %>% filter(grepl("Cycle", Name)) 
diver.ob.good$Name = gsub("Cycle", "", diver.ob.good$Name)

ob.corr.p = ggplot(diver.ob.good, aes(x=as.numeric(Name), y=as.numeric(value)), color=Name, fill=Name) + 
  geom_point(aes(color=Name)) + ylab("Observed ASVs") +
  xlab("Propagation cycle") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), size=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=unique(diver.ob.good$RGBcol))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6), labels = c(1,2,3,4,5,6))+
  scale_fill_manual(values=unique(diver.ob.good$RGBcol))+
  theme_pubclean()+ theme(axis.line = element_line())


#SHANNON
diver.sha.good = diver.sha$data %>% filter(grepl("Cycle", Name)) 
diver.sha.good$Name = gsub("Cycle", "", diver.sha.good$Name)

sha.corr.p = ggplot(diver.sha.good, aes(x=as.numeric(Name), y=as.numeric(value)), color=Name, fill=Name) + 
  geom_point(aes(color=Name)) + ylab("Shannon") +
  xlab("Propagation cycle") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), size=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=unique(diver.sha.good$RGBcol))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6), labels = c(1,2,3,4,5,6))+
  scale_fill_manual(values=unique(diver.sha.good$RGBcol))+
  theme_pubclean()+ theme(axis.line = element_line())

#SIMPSON
diver.sim.good = diver.sim$data %>% filter(grepl("Cycle", Name)) 
diver.sim.good$Name = gsub("Cycle", "", diver.sim.good$Name)

sim.corr.p = ggplot(diver.sim.good, aes(x=as.numeric(Name), y=as.numeric(value)), color=Name, fill=Name) + 
  geom_point(aes(color=Name)) + ylab("Simpson") +
  xlab("Propagation cycle") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), size=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=unique(diver.sha.good$RGBcol))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6), labels = c(1,2,3,4,5,6))+
  scale_fill_manual(values=unique(diver.sha.good$RGBcol))+
  theme_pubclean()+ theme(axis.line = element_line())


#PD
diver.pd.good = diver.pd$data %>% filter(grepl("Cycle", Name)) 
diver.pd.good$Name = gsub("Cycle", "", diver.pd.good$Name)

pd.corr.p = ggplot(diver.pd.good, aes(x=as.numeric(Name), y=as.numeric(PD)), color=Name, fill=Name) + 
  geom_point(aes(color=Name)) + ylab("PD") +
  xlab("Propagation cycle") + ggtitle("Spearman correlation")+
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs", k=3), size=0.5) +
  stat_cor(method = "spearman") +
  scale_color_manual(values=unique(diver.sha.good$RGBcol))+
  scale_x_continuous(breaks = c(1,2,3,4,5,6), labels = c(1,2,3,4,5,6))+
  scale_fill_manual(values=unique(diver.sha.good$RGBcol))+
  theme_pubclean()+ theme(axis.line = element_line())

#Combined plot
ggarrange(ob.corr.p +theme(legend.position = "", axis.line = element_line()),
          sha.corr.p +theme(legend.position = "", axis.line = element_line()),
          pd.corr.p +theme(legend.position = "", axis.line = element_line()),
          sim.corr.p+theme(legend.position = "", axis.line = element_line()),
          ncol=2, nrow = 2, common.legend = T, legend = "bottom", align = "hv")

```


#10. Phylogenetic distribution of ASVs


```{r}
#Merge replicates
ps2.css.merg = merge_samples2(ps2.css, "Name")
ps2.css.merg.prop = transform_sample_counts(ps2.css.merg, function(x) {x/sum(x)*100})
#Filter by a minimum relative abundance of 0.005
ps2.css.merg.propF = filter_taxa(ps2.css.merg.prop, function(x) mean(x) >= 0.005, TRUE)

treep = ggtree(ps2.css.merg.propF, layout = "fan", branch.length='none', right = T, open.angle = 45, size=0.15) +
  geom_tippoint(aes(fill=Phylum),size=1.4, alpha=0.9, shape=21) +
  geom_tiplab2(aes(label=Genus), as_ylab=TRUE, size = 0.6, offset=25, align=T, hjust = 0, linetype='dotted')+
  geom_fruit(geom=geom_point, shape= 16,
             mapping = aes(x=reorder(Name, Order2),
                           color=Name, 
                           size=Abundance),
             axis.params=list(axis="x", text.angle= 90, text.size=1, line.size = 0, vjust = 0.5, hjust=1)) +
  scale_color_manual(values=unique(metadata$RGBcol)) +
  scale_fill_manual(values=ocean.balance(22))+
  scale_size_continuous(range=c(0,10), breaks = c(0.5, 1, 2, 3, 5, 7, 10))+
  geom_treescale(fontsize=1.2, linesize=0.3, x=0.7, color = "red") +
  theme(legend.position = "bottom")

#add bootstrap >= 70
treep + geom_nodepoint(aes(subset = (label) >= 70))

```

# 11. Bray-Curtis dissimilarities heatmap

```{r }
bray=as.data.frame(as.matrix(phyloseq::distance(ps2.css.prop, method="bray")))

sampdata = data.frame(sample_data(ps2)) %>% select(-id_samples, -Names_rep, -Replicate) %>% group_by(Name) %>% unique()
sampdata$id_samples = sampdata$Name

#Calculate ordering for columns and rows (for annotations of the matrix)
clust.order = hclust(dist(bray))
#and merge with the sample_data to optaion the rest of the annotations in order
clust.order = data.frame("Name"=clust.order$labels) %>% left_join(data.frame(sample_data(ps2)), by="Name") %>% 
  select(-id_samples, -Names_rep, -Replicate) %>% 
  group_by(Name) %>% 
  unique()


Heatmap(as.matrix(bray), col = ocean.matter(100), column_dend_height = unit(2, "cm"), row_dend_width = unit(2, "cm"),
        top_annotation = HeatmapAnnotation("Samples"=clust.order$Name,  col = list(Name = metadata$Name, colors = metadata$RGBcol)),
        left_annotation = rowAnnotation("Samples"=clust.order$Name),
        width = ncol(bray)*unit(5, "mm"), height = nrow(bray)*unit(5, "mm"), column_km=3, row_km=3)

```

# 12. NMDS / PCoA

```{r}
#PCoA
set.seed(12345)
ord.pcoa.bray = ordinate(ps2.css.prop, method = "PCoA", distance = "bray")
scrs.bray = as.data.frame(ord.pcoa.bray$vectors)
scrs.bray = scrs.bray %>% select(Axis.1, Axis.2, Axis.3, Axis.4, Axis.5) %>% rownames_to_column(var="id_samples") %>% left_join(metadata, by=c("id_samples"))

cen.bray = aggregate(cbind(Axis.1, Axis.2, Axis.3, Axis.4, Axis.5) ~ Name, data = scrs.bray, FUN = mean)
segs.bray = merge(scrs.bray, setNames(cen.bray, c('Name', 'oAxis1','oAxis2', 'oAxis3', 'oAxis4', 'oAxis5')),
              by = 'Name', sort = FALSE)

plot_ordination(ps2.css.prop, ord.pcoa.bray, color="Name", title="Bray PCoA", ) + geom_point(alpha=0.1) +
  geom_segment(data = segs.bray, mapping = aes(xend = oAxis1, yend = oAxis2), size=0.5, alpha=0.25) +
  geom_point(data = cen.bray, size = 2) +
  stat_ellipse(level = 0.99, alpha=0.4)+
  geom_hline(yintercept = 0, linetype="dashed", color="grey") +
  geom_vline(xintercept = 0, linetype="dashed", color="grey") +
  scale_color_manual(values=unique(metadata$RGBcol))+
  scale_fill_manual(values=unique(metadata$RGBcol))+
  ggrepel::geom_text_repel(data = cen.bray, label=cen.bray$Name, force = 2)+
  theme_classic2()
```

#13 Contribion of Soil/SSbRB to the RhizCom

First, plot only the 3 conditions in a ggallubial plot:

```{r warning=FALSE}
ps2.css.merg = merge_samples(ps2.css, "Name", fun=mean) #merge replicates
ps2.css.merg = transform_sample_counts(ps2.css.merg, function(x) {x/sum(x)*100}) #transformed to rel. abundance
sample_data(ps2.css.merg)$Name = sample_names(ps2.css.merg) #remap the names

#Filter for the conditions that we want.
ps2.css.filt = subset_samples(ps2.css.merg, Name == "SoilWash" | Name == "Cycle6" | Name == "SbRB")
ps2.css.filt = prune_taxa(taxa_sums(ps2.css.filt) > 0, ps2.css.filt)

#Obtain list of ASVs in RhizCom:
rhizcom=subset_samples(ps2.css.merg, Name=="Cycle6")
rhizcom=prune_taxa(taxa_sums(rhizcom) > 0, rhizcom)
rhizcomASVs = taxa_names(rhizcom)

#prune the ps object for only RhizCom ASVs
ps2.css.filt = prune_taxa(rhizcomASVs, ps2.css.filt)
ps2.css.filt=prune_taxa(taxa_sums(ps2.css.filt) > 0, ps2.css.filt)


ps2.css.filtno = psmelt(ps2.css.filt) %>% 
  select(-id_samples, -Order2, -Replicate, -Names_rep, -RGBcol)

ps2.css.filtno$count[ps2.css.filtno$Abundance > 0] = 1
ps2.css.filtno$count[ps2.css.filtno$Abundance == 0] = NA
ps2.css.filtno$Abundance[ps2.css.filtno$Abundance == 0] = NA

allu_abund = ggplot(ps2.css.filtno, 
       aes(y=Abundance, x=reorder(Sample, sample_Order)))+
  geom_flow(aes(alluvium=OTU, fill=Class, color=Class), 
            alpha = 0.5, curve_type = "xspline", width = 0.5, aes.bind = TRUE)+
  geom_stratum(width = 0.5, aes(fill=Class, color=Class, stratum=OTU))+
  stat_summary(aes(label=stat(y)), fun.y = "sum", geom="text", colour="red", size=4)+
  scale_fill_manual(values=c("#439B5B", "#7BC369", "#ABD69A", "#D8E8B0", "#CCCDA7", "#92B2B2", "#61ACC1", "#58A0C4", "#7087C3", "#8973B4", "#512972"))+
  scale_color_manual(values=c("#439B5B", "#7BC369", "#ABD69A", "#D8E8B0", "#CCCDA7", "#92B2B2", "#61ACC1", "#58A0C4", "#7087C3", "#8973B4", "#512972"))+
  theme_pubclean() + theme(legend.position="right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

allu_count = ggplot(ps2.css.filtno, 
       aes(y=count, x=reorder(Sample, sample_Order)))+
  geom_flow(aes(alluvium=OTU, fill=Class, color=Class), 
            alpha = 0.5, curve_type = "xspline", width = 0.5, aes.bind = TRUE)+
  geom_stratum(width = 0.5, aes(fill=Class, color=Class, stratum=reorder(OTU, Class)))+
  stat_summary(aes(label=stat(y)), fun.y = "sum", geom="text", colour="red", size=4)+
  scale_fill_manual(values=c("#439B5B", "#7BC369", "#ABD69A", "#D8E8B0", "#CCCDA7", "#92B2B2", "#61ACC1", "#58A0C4", "#7087C3", "#8973B4", "#512972"))+
  scale_color_manual(values=c("#439B5B", "#7BC369", "#ABD69A", "#D8E8B0", "#CCCDA7", "#92B2B2", "#61ACC1", "#58A0C4", "#7087C3", "#8973B4", "#512972"))+
  theme_pubclean() + theme(legend.position="right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggarrange(allu_abund, allu_count, ncol = 2, common.legend = T)
```

##13.1 Numbers of ASVs, species, genera

Lets count ASVs total in each of the samples to see if they are a big part or not:

```{r message=FALSE, warning=FALSE}
counting_tax = data.frame(row.names =c("Sample", "Tax_level", "Number"))
for (i in c("SbRB", "Cycle6", "Recovered", "Soil", "SoilWash")){
  for (j in c("ASVs", "Species", "Genus")){
    if (j == "ASVs"){
      count = subset_samples(ps2.css.merg, Name == i) %>% 
        prune_taxa(taxa_sums(.) > 0,.) %>% otu_table(.) %>% ncol()
      counting_res = c(ifelse(i == "Cycle6", "RhizCom", i), j, count)
      counting_tax = cbind(counting_tax, counting_res)
    }else{
      count = tax_glom(subset_samples(ps2.css.merg, Name == i) %>% 
                         prune_taxa(taxa_sums(.) > 0,.), j, NArm = F) %>% 
        otu_table(.) %>% ncol()
      counting_res = c(ifelse(i == "Cycle6", "RhizCom", i), j, count)
      counting_tax = cbind(counting_tax, counting_res)
    }
  }
}
counting_tax = as.data.frame(t(counting_tax), row.names = F)
counting_tax

#save
#write.table(counting_tax, "counting_tax.txt", quote = F, sep = "\t", row.names = F)

```

##13.2 Dough plot

```{r}
ps2.css.merg = merge_samples(ps2.css, "Name", fun=mean) #merge replicates
ps2.css.merg = transform_sample_counts(ps2.css.merg, function(x) {x/sum(x)*100}) #transformed to rel. abundance
sample_data(ps2.css.merg)$Name = sample_names(ps2.css.merg) #remap the names

#Obtain list of ASVs in RhizCom:
rhizcom=subset_samples(ps2.css.merg, Name=="Cycle6")
rhizcom=prune_taxa(taxa_sums(rhizcom) > 0, rhizcom)
rhizcomASVs = taxa_names(rhizcom)

#prune the ps object for only RhizCom ASVs
ps2.css.filt = prune_taxa(rhizcomASVs, ps2.css.merg)
ps2.css.filt=prune_taxa(taxa_sums(ps2.css.filt) > 0, ps2.css.filt)



ps2.css.merg.df = t(as.data.frame(otu_table(ps2.css.filt))) %>% as.data.frame() %>%
  mutate(Cycles15Mean = rowMeans(select(.,Cycle1, Cycle2, Cycle3, Cycle4, Cycle5))) #mean cycles
nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SoilWash == 0 & SbRB == 0)) #Not traced to Soil or SbRB
nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SoilWash == 0 & SbRB == 0 & Cycles15Mean == 0 & Soil == 0)) #Not traced to anything
nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SoilWash > 0 | SbRB > 0)) #Traced to SoilWash or SbRB
nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SoilWash == 0 & SbRB == 0 & Cycles15Mean > 0)) #Traced to Cycles
nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SbRB > 0)) #traced to SbRB
nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SoilWash > 0)) #traced to SoilWash
#Some of them overlap! so I cannot represent both as independent.

#lets generate a simple doughnut chart with this information
dough.data = data.frame(category=c("Not tracked", "Tracked SbRB/Soilwash", "Tracked Cycles"),
                        count = c(nrow(filter(data.frame(ps2.css.merg.df), 
                                              Cycle6 > 0 & SoilWash == 0 & SbRB == 0 & Cycles15Mean == 0 & Soil == 0)),
                                  nrow(filter(data.frame(ps2.css.merg.df), Cycle6 > 0 & SoilWash > 0 | SbRB > 0)),
                                  nrow(filter(data.frame(ps2.css.merg.df), 
                                              Cycle6 > 0 & SoilWash == 0 & SbRB == 0 & Cycles15Mean > 0))))

dough.data$fraction = dough.data$count / sum(dough.data$count)
dough.data$ymax = cumsum(dough.data$fraction)
dough.data$ymin = c(0, head(dough.data$ymax, n=-1))
dough.data$labelPosition <- (dough.data$ymax + dough.data$ymin) / 2

# Compute a good label
dough.data$label <- paste0(dough.data$category, "\n value: ", dough.data$count)
dough.data

ggplot(dough.data, aes(ymax=ymax, ymin=ymin, xmax=4,xmin=3.3, fill=category))+
  geom_rect()+
  coord_polar(theta="y")+
  geom_text(x=3, aes(y=labelPosition, label=label, color=category), size=4)+
  xlim(c(2,4))+
  scale_fill_brewer(palette=2)+
  scale_color_brewer(palette=2)+
  theme_void()
```


##13.3 Emergence of new ASVs

We can plot the number of new ASVs that are appear each cycle, to see if is also stabilizing. And represent this by the aundance.

```{r}
#Define thresholds:

abund_thrs = c(0.001, 0.01, 0.1, 1)

newASVs_summary_res = data.frame()

for (i in abund_thrs) {
  newASVs_thrs <- ps2.css.merg.df %>%
    filter(Cycle6 >= i) %>%
    mutate(
      emergC1 = ifelse(Cycle1 > 0, 1, 0),
      emergC2 = ifelse(Cycle2 > 0 & Cycle1 == 0, 1, 0),
      emergC3 = ifelse(Cycle3 > 0 & Cycle1 == 0 & Cycle2 == 0, 1, 0),
      emergC4 = ifelse(Cycle4 > 0 & Cycle1 == 0 & Cycle2 == 0 & Cycle3 == 0, 1, 0),
      emergC5 = ifelse(Cycle5 > 0 & Cycle1 == 0 & Cycle2 == 0 & Cycle3 == 0 & Cycle4 == 0, 1, 0),
      emergC6 = ifelse(Cycle6 > 0 & Cycle1 == 0 & Cycle2 == 0 & Cycle3 == 0 & Cycle4 == 0 & Cycle5 == 0, 1, 0)
    ) %>%
    summarise(
      emergC1 = sum(emergC1),
      emergC2 = sum(emergC2),
      emergC3 = sum(emergC3),
      emergC4 = sum(emergC4),
      emergC5 = sum(emergC5),
      emergC6 = sum(emergC6)
    ) %>%
    pivot_longer(cols = everything(), names_to = "Cycle", values_to = "TotalEmergences")
  
  newASVs_thrs <- newASVs_thrs %>% mutate(Threshold = i)
  newASVs_summary_res <- rbind(newASVs_summary_res, newASVs_thrs)
}

head(newASVs_summary_res)

#Plot it as counts:
ggplot(newASVs_summary_res, aes(x=Cycle, y=TotalEmergences, color = as.factor(Threshold), group = Threshold))+
  geom_line() + geom_point() +
  theme_pubr() + theme(legend.position="right", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  
```


# 14. Differential abundane

We first need the phyloseq object (ps2) in our case. We are going to use this phyloseq object to filter the two conditions we want to compare, for which I'll define them first. Our samples names are:

```{r}
unique(sample_data(ps2)$Names)
```
The samples that make sense to compare are:
  1. Soil vs. SoilWash - influence of the wash step
  2. Soil vs. cycle 6 - what was selected?
  3. SbRB vs. cycle 6 - which of the SbRB were lost or did not form part of the RhizCom?
  4. Cycle 6 vs. Recovered - how different is the recover community 

Define the comparisons we are interested in:

```{r}
daa.comparisons = list(c("Soil", "SoilWash"), 
                       c("SoilWash", "Cycle6"),
                       c("Cycle6", "Recovered"), 
                       c("SbRB", "Cycle6"))
```


Iterate thought this list to calculate the differential abundance of ASVs:

```{r, eval=FALSE}
daa.comparisons[[1]][2]

#define cutoffs for differential abundance
alpha=0.01
l2FC = 2.5

n= 0
p= list()
c= list()
all_results = data.frame()
all_counts = data.frame()

for (x in daa.comparisons){
  n=n+1 
  new_phylo = subset_samples(ps2, Name == daa.comparisons[[n]][1] | Name == daa.comparisons[[n]][2])
  new_phylo = prune_taxa(taxa_sums(new_phylo) > 0, new_phylo)
  #perform the deseq
  deseq = phyloseq_to_deseq2(new_phylo, ~Name)
  daa = DESeq(deseq, test = "Wald", fitType = "local")
  res=results(daa,cooksCutoff = F)
  
  filename = paste0("DESeq2/", n, "_DESeq2_raw_", levels(deseq$Name)[1], "_vs_", levels(deseq$Name)[2], "_table.tab")
  write.table(cbind(as(res, "data.frame"), as(tax_table(new_phylo)[rownames(res), ], "matrix")), 
              file= filename, quote=F, sep="\t")
  
  #FILTER FOR VOLCANO PLOT
  volcano = cbind(as(res, "data.frame"), as(tax_table(new_phylo)[rownames(res), ], "matrix"))
  #add the condition!!
  volcano$condition = paste0(n,"_",levels(deseq$Name)[1], "_vs_", levels(deseq$Name)[2])
  volcano$diffexpressed = "NO"
  volcano$diffexpressed[volcano$log2FoldChange <= -l2FC & volcano$padj < 0.01] = paste0(levels(deseq$Name)[1])
  volcano$diffexpressed[volcano$log2FoldChange >= l2FC & volcano$padj < 0.01] = paste0(levels(deseq$Name)[2])
  #second codition for "venn diagrams"
  volcano$cond = "NO"
  volcano$cond[volcano$log2FoldChange <= -l2FC & volcano$padj < 0.01] = "condition1"
  volcano$cond[volcano$log2FoldChange >= l2FC & volcano$padj < 0.01] = "condition2"
  #labels
  volcano$label = NA
  volcano$Genus = gsub('Allorhizobium-Neorhizobium-Pararhizobium-Rhizobium', "Rhizobium group", volcano$Genus)
  volcano$Genus = gsub('Burkholderia-Caballeronia-Paraburkholderia', "Burkholderia group", volcano$Genus)
  volcano$Genus = gsub('sensu stricto', "ss.", volcano$Genus)
  volcano$Genus = gsub('Candidatus', "Ca.", volcano$Genus)
  volcano$label[volcano$diffexpressed != "NO"] = volcano$Genus[volcano$diffexpressed != "NO"]
  #remove the uncultured from labels! NAs are not written!
  volcano$label = gsub('uncultured', NA, volcano$label)
  

  #For color according to Phylum:
  volcano$PhylumCol = volcano$Phylum
  volcano$PhylumCol[volcano$diffexpressed == "NO"] = "Not sigificant"
  #lets add the abundance
  phylo.ra = transform_sample_counts(new_phylo, function(x) x / sum(x) * 100)
  phylo.ra.merg = merge_samples2(phylo.ra, group = "Name", fun_otu=mean)
  
  abundance.df = as.data.frame(t(otu_table(phylo.ra.merg))) %>% rownames_to_column(var = "asvs")
  colnames(abundance.df) = c("asvs", "condition1.ab", "condition2.ab")
  volcano = rownames_to_column(volcano, var="asvs")
  volcano = left_join(volcano, abundance.df, by=c("asvs"))
  
  volcano$abundance[volcano$log2FoldChange < 0] = volcano$condition1.ab[volcano$log2FoldChange < 0]
  volcano$abundance[volcano$log2FoldChange > 0] = volcano$condition2.ab[volcano$log2FoldChange > 0]
  
  #only for the 7 top most abundant phyla:
  volcano$Color = NA
  volcano = volcano %>% 
    mutate(Color = ifelse(PhylumCol %in% c("Proteobacteria",
                                           "Bacteroidota",
                                           "Firmicutes",
                                           "Verrucomicrobiota",
                                           "Planctomycetota",
                                           "Acidobacteriota",
                                           "Actinobacteriota", 
                                           "Not sigificant"), 
                          PhylumCol, "Other"))
  
  #Create a new label only for taxa with and abundance > 0.1
  volcano$label2 = NA
  volcano$label2[volcano$abundance >= 0.05 & volcano$diffexpressed != "NO"] = volcano$label[volcano$abundance >= 0.05 & volcano$diffexpressed != "NO"]
  
#  p[[n]] = ggplot(volcano, aes(x=log2FoldChange, y=-log(padj,10), col=Color, label=label)) + 
#    geom_point(aes(size=abund_levels), alpha=0.25, shape=16)+
#    geom_text_repel(aes(label=label), max.overlaps = 40, size=2)+
#    geom_vline(xintercept=c(2.5, -2.5), col="grey", alpha=0.5)+
#    geom_hline(yintercept=-log10(0.01), col="grey", alpha=0.5)+
#    scale_color_manual(values=rev(c("dodgerblue4", "cadetblue3", "darkseagreen4", 
#                                    "palegreen3", "grey", "coral2", "tan", 
#                                    "deeppink4", "purple3")))  +
#    ggtitle(paste(daa.comparisons[[n]][1]," vs. ",daa.comparisons[[n]][2])) +
#    theme_classic2()
  
  #Calculate the counts of diff expressed per condition.
  counts = volcano %>% group_by(condition, cond) %>% dplyr::count()
  
#  c[[n]] = ggplot() +
#    geom_circle(aes(x0 = c(0, 1), y0 = c(0, 0), r = 1), fill = "black", alpha = 0.3, color=NA) +
#    ggtitle(counts$condition)+
#    geom_text(aes(x=-0.5, y=0), size=2, label = counts$n[1]) +
#    geom_text(aes(x=0.5, y=0), size=2, label = counts$n[3]) +
#    geom_text(aes(x=1.5, y=0), size=2, label = counts$n[2]) +
#    theme_void()
  
  #save the volcano cand counts results as a combination of comparisons tables
  all_results = rbind(all_results, volcano)
  all_counts = rbind(all_counts, counts)
}

daa.results = all_results

#save all results
#write.table(all_results, "DESeq2/all_results.txt", quote = F, sep="\t", row.names = F)
#write.table(all_counts, "DESeq2/all_counts.txt", quote = F, sep="\t", row.names = F)

#load all results
#daa.results = read.table("DESeq2/all_results.txt", header = T, sep = "\t")
```


Our choice for only retain the names of the top 7 most abundant phyla and collapse the rest into "Other" is because of their distribution:

```{r}
ggplot(data.frame(tax_table(ps2.css.merg)) %>% select(Phylum) %>% group_by(Phylum) %>% dplyr::count(sort= T), 
       aes(x=reorder(Phylum, n), y=n))+
  geom_bar(stat="identity", aes(fill=reorder(Phylum, n)), colour="black", alpha=0.75)+
  scale_fill_manual(values=rev(ocean.ice(22)))+
  xlab("Phylum") + ylab("ASV count")+
  coord_flip() +
  theme_pubclean()+theme(legend.position = "right", axis.line = element_line())

```

## 14.1 Volcano plots

```{r}
ggplot(daa.results, aes(x=log2FoldChange, y=-log(padj,10), col=Color)) + 
  geom_point(alpha = 0.5, shape=16, aes(size=abundance)) +
  geom_text_repel(data=filter(daa.results, abundance >= 0.075), aes(label=label2), max.overlaps = 45, size=2, force = 4) +
  geom_vline(xintercept=c(2.5, -2.5), col="grey", alpha=0.5) +
  geom_hline(yintercept=-log10(0.01), col="grey", alpha=0.5) +
  #scale_color_manual(values =rev(c(ocean.deep(4), "grey", ocean.speed(4)))) +
  scale_size_continuous(range = c(1, 5), breaks = c(0.001, 0.01, 0.1, 1, 10))+
  scale_color_manual(values=c("#25725d","#439b5b","#abd69a","#92b2b2", "grey50", "#c48070","#7087c3","#8973b4","#512972"))  +
  ggtitle("Differentially Abundant ASVs, named only 0.05 or more RA") +
  facet_wrap(~condition, nrow = 2, scales = "free") +
  theme_classic2() + theme(strip.background = element_blank())

```


## 14.2 Counts per condition


```{r}
as.data.frame(all_counts)
```

End of the amplicon sequencing analysis.

